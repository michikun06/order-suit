import { toArray as _toArray, toConsumableArray as _toConsumableArray } from '../../../_virtual/_rollupPluginBabelHelpers.js';
import { createElement } from 'react';
import _pt from 'prop-types';
import Markdown from '../../../node_modules/markdown-to-jsx/dist/index.module.esm.js';

// Stores every last index owning a " |" string
// to close the code block at the good position
//
// Example code block:
// 15 |           frontmatter {
// 16 |             date(formatString: $invaludVar)
//    |                                ^
//

var formatCodeBlocks = function formatCodeBlocks(stringPartsByLines) {
  var lastIndexFound = -1;
  var codeBlockOpen = false;
  var nextLines = stringPartsByLines.map(function (str, index) {
    if (str.match(/(\s|\t)*\d+\s\|/) || str.match(/(\s|\t)*\|(\s|\t)*\^/)) {
      if (codeBlockOpen) {
        lastIndexFound = index;
      } else {
        codeBlockOpen = true;
        return "```" + str;
      }
    } else if (codeBlockOpen) {
      // Close the current code block if the line doesn't match anymore
      codeBlockOpen = false;
      return "```" + str;
    }

    return str;
  });

  if (lastIndexFound > -1) {
    nextLines[lastIndexFound] = nextLines[lastIndexFound] + "```";
  }

  return nextLines.join("\n");
};

var FormattedMessage = function FormattedMessage(_ref) {
  var rawMessage = _ref.rawMessage;
  var stringPartsByLines = rawMessage.split("\n");
  var message = formatCodeBlocks(stringPartsByLines); // Markdown formatter treats strings without line break as spans, we need to wrap them in a
  // <div><p></p></div> to keep the same structure as a multi line message.

  var isOneLine = stringPartsByLines.length === 1;

  if (isOneLine) {
    return /*#__PURE__*/createElement("div", null, /*#__PURE__*/createElement("p", null, /*#__PURE__*/createElement(Markdown, null, message)));
  }

  var firstLine = stringPartsByLines[0]; // Line breaking to create a title at the first ":" met

  if (firstLine.endsWith(":")) {
    return /*#__PURE__*/createElement(Markdown, null, message.replace(":", ":\n\n"));
  } // Line breaking to create a title when the first line ends with "."


  if (firstLine.endsWith(".")) {
    var _stringPartsByLines = _toArray(stringPartsByLines),
        _ = _stringPartsByLines[0],
        actual = _stringPartsByLines.slice(1);

    var newFirstLine = firstLine.substring(0, firstLine.length - 1);
    var nextMessage = ["".concat(newFirstLine, ".\n\n")].concat(_toConsumableArray(actual)).join("\n");
    return /*#__PURE__*/createElement(Markdown, null, nextMessage);
  }

  return /*#__PURE__*/createElement(Markdown, null, message);
};
FormattedMessage.propTypes = {
  rawMessage: _pt.string.isRequired
};
FormattedMessage.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormattedMessage",
  "props": {
    "rawMessage": {
      "required": true,
      "tsType": {
        "name": "string"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BuildLogs/FormattedMessage.tsx"] = {
    name: "FormattedMessage",
    docgenInfo: FormattedMessage.__docgenInfo,
    path: "src/components/BuildLogs/FormattedMessage.tsx"
  };
}

export { FormattedMessage };
//# sourceMappingURL=FormattedMessage.esm.js.map
